syntax = "proto3";

package vm_grpc;

// Status of contract execution.
enum ContractStatus {
    Discard = 0; // If transaction should be ignored, because of error.
    Keep = 1; // If we keep transaction and write write_set.
}

// Status of code contract execution.
message VMStatus {
    uint64 major_status = 1; // Major status.
    uint64 sub_status = 2; // Sub status if needed (optional).
    string message = 3; // Message with error details if needed (optional).
}

// Type of contract argument.
enum VMTypeTag {
    Bool = 0; // Bool 0x0 - false, 0x1 - true.
    U64 = 1; // Uint64. Little-endian unsigned 64 bits integer.
    Vector = 2; // Vector of bytes.
    Address = 3; // Address, in bech32 form. 20 bytes.
    U8 = 4; // U8
    U128 = 5; // U128 Little-endian unsigned 128 bits integer.
}

/// Full name of the structure.
message StructIdent {
    bytes address = 1; // address of module owner
    string module = 2; // module name.
    string name = 3; // name of structure.
    repeated LcsTag type_params = 4; // Structure type parameters.
}

enum LcsType {
    LcsBool = 0; // Bool
    LcsU64 = 1; // Uint64
    LcsVector = 2; // Vector of bytes.
    LcsAddress = 3; // Address, in bech32 form
    LcsU8 = 4; // U8
    LcsU128 = 5; // U128
    LcsSigner = 6; // Signer.
    LcsStruct = 7; // Struct.
}

message LcsTag {
    LcsType type_tag = 1; // type tag.
    LcsTag vector_type = 2; // vector type. Has a non-null value if the type_tag is equal to a LcsVector.
    StructIdent struct_ident = 3; // struct identifier. Has a non-null value if the type_tag is equal to a LcsStruct.
}

/// Module identifier.
message ModuleIdent {
    bytes address = 1; // module address.
    string name = 2; // module name.
}

// VM event returns after contract execution.
message VMEvent {
    bytes sender_address = 1; // Event sender address.
    ModuleIdent sender_module = 2; // sender module.
    LcsTag event_type = 3; // Type of value inside event.
    bytes event_data = 4; // Event data in bytes to parse.
}

// Write set operation type.
enum VmWriteOp {
    Value = 0; // Insert or update value
    Deletion = 1; // Delete.
}

// Storage path
message VMAccessPath {
    bytes address = 1; // account address.
    bytes path = 2; // storage path.
}

// VM value should be passed before execution and return after execution (with opcodes), write_set in nutshell.
message VMValue {
    VmWriteOp type = 2; // Type of operation
    bytes value = 1; // Value returns from vm.
    VMAccessPath path = 3; // Access path.
}

// Contract arguments.
message VMArgs {
    VMTypeTag type = 1; // Argument type.
    bytes value = 2; // Argument value.
}

// Publish module.
message VMPublishModule {
    bytes address = 1; // owner of contract (module) or script executor.
    uint64 max_gas_amount = 2; // maximal total gas specified by wallet to spend for this transaction.
    uint64 gas_unit_price = 3; // maximal price can be paid per gas.
    bytes code = 4; // compiled contract code.
}

// VM contract object to process.
message VMExecuteScript {
    bytes address = 1; // owner of contract (module) or script executor.
    uint64 max_gas_amount = 2; // maximal total gas specified by wallet to spend for this transaction.
    uint64 gas_unit_price = 3; // maximal price can be paid per gas.
    bytes code = 4; // compiled contract code.
    repeated StructIdent type_params = 7; // type parameters.
    repeated VMArgs args = 8; // Contract arguments.
}

// Response from VM contains write_set, events, gas used and status for specific contract.
message VMExecuteResponse {
    repeated VMValue write_set = 1; // using string instead of bytes for now, as map support only ints and strings as keys
    repeated VMEvent events = 2; // list of events executed during contract execution
    uint64 gas_used = 3; // Gas used during execution.
    ContractStatus status = 4; // Status of contract execution.
    VMStatus statusStruct = 5; // Main status of execution, might contain an error.
}

// GRPC service
service VMModulePublisher {
    rpc PublishModule (VMPublishModule) returns (VMExecuteResponse) {
    }
}

service VMScriptExecutor {
    rpc ExecuteScript (VMExecuteScript) returns (VMExecuteResponse) {
    }
}

// Compiler API
message SourceFile {
    string text = 1; // utf8 encoded source code with libra/bech32 addresses
    bytes address = 2; // address of the sender, in bech32 form
}

// Compilation unit.
message CompilationUnit {
    string text = 1; // utf8 encoded source code with libra/bech32 addresses
    string name = 2; // name of the unit.
}

// Compiler API
message SourceFiles {
    repeated CompilationUnit units = 1; // Compilation units.
    bytes address = 2; // address of the sender, in bech32 form
}

// Compiled source.
message CompiledUnit {
    string name = 1; // name of the module/script.
    bytes bytecode = 2; // bytecode of the compiled module/script
}

message MultipleCompilationResult {
    repeated CompiledUnit units = 1;
    repeated string errors = 2; // list of error messages, empty if successful
}

message CompilationResult {
    bytes bytecode = 1; // bytecode of the compiled module/script
    repeated string errors = 2; // list of error messages, empty if successful
}

service VMCompiler {
    rpc Compile (SourceFile) returns (CompilationResult) {
    }
}

service VMMultipleSourcesCompiler {
    rpc Compile (SourceFiles) returns (MultipleCompilationResult) {
    }
}

// Script Arguments API
message VMScript {
    bytes code = 1; // bytecode of script
}

message Signature {
    repeated VMTypeTag arguments = 1;
}

// Returns argument names/types for script.
service VMScriptMetadata {
    rpc GetSignature (VMScript) returns (Signature) {
    }
}

/// Resource access path.
message AccessVector {
    bytes access_vector = 1;
}

/// Returns the structure access vector.
service VMAccessVector {
    rpc GetAccessVector (StructIdent) returns (AccessVector) {
    }
}